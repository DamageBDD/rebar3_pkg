#!/bin/sh
# portable header for dpkg maintainer scripts
set -eu
set -x
umask 022
export DEBIAN_FRONTEND=noninteractive
PATH=/usr/sbin:/usr/bin:/sbin:/bin

on_exit() {
  rc=$?
  if [ "$rc" -ne 0 ]; then
    echo "[postinst] FAILED (rc=$rc)" >&2
  else
    echo "[postinst] OK" >&2
  fi
}
trap on_exit EXIT HUP INT TERM



export APP="{{app}}"
export PREFIX="{{install_prefix}}"
export PKG_NAME="{{app}}"
# Paths produced by your package layout
export PREFIX="{{install_prefix}}"
export BIN="${PREFIX}/bin/{{app}}"
export LINK="/usr/bin/{{app}}"
export ETC_DIR="{{etc_dir}}"
export VAR_DIR="{{var_dir}}"
export LOG_DIR="{{log_dir}}"
# Service/user knobs (string flags so we can test in shell)
export CREATE_USER="{{create_user}}"        # "true" or "false"
export USER="{{user}}"
export GROUP="{{group}}"
export SERVICE_NAME="{{service_name}}"
export AUTO_START="{{auto_start}}"          # "true" or "false"

# Candidate hook directories:
# 1) Optional system hook dir (if you ever stage one)
# 2) The relx app priv path shipped in the package
HOOK_DIRS="
/usr/lib/${APP}/postinst.d
${PREFIX}/lib/${APP}-*/priv/pkg/postinst.d
/opt/${APP}/lib/${APP}-*/priv/pkg/postinst.d
"

run_hooks_dir() {
  d="$1"
  [ -d "$d" ] || return 0

  # Prefer run-parts if available; fallback to POSIX loop
  if command -v run-parts >/dev/null 2>&1; then
    # run-parts does not expand globs, so iterate matches
    for m in $d; do
      [ -d "$m" ] || continue
      run-parts --exit-on-error "$m"
    done
  else
    for m in $d; do
      [ -d "$m" ] || continue
      for f in "$m"/*; do
        [ -f "$f" ] || continue
        chmod +x "$f" || true
        "$f"
      done
    done
  fi
}

# Execute hooks in order for each candidate directory
for dir in $HOOK_DIRS; do
  run_hooks_dir "$dir"
done

exit 0

